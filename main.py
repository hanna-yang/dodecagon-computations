from sage.all import *
from j_invariant_computations import *
from symbolic_wrappers import *
from dodecagon_maker import *
from misc import *

"""
Let the vertices, in clockwise order of the dodecagon, starting from
(1, 0) be v0, v1, v2, ... v11
"""

def compute_60_deg_gb():
    """
    prints out the groebner basis generated by the following expressions
    (set equal to zero)
    - the projection of the j-invariant, Jvv, along the directions of
    vectors connecting:
        -
    - the irrational component of the numerator of
    -
    one can verify that the only solutions are
    b1=c1=0
    and
    a1=0, b1=1/2, c1=1/2, d1=0
    either by hand, or asking sage to solve the series of equations which are printed.
    """
    equations_to_zero = []
    p = make_60_deg_sym_gon()

    # compute the equations corresponding to zero-ing of j-invariant
    print("computing equations arising from j-invt")
    exp_assumption = []
    for i in range(2,4):
        exp_assumption += expressions_to_zero(i, polygon=p)[:2]
    nums = [e.numerator()(D=Integer(3)) for e in exp_assumption if e is not None]
    equations_to_zero += nums

    # compute the equations corresponding the zero-ing of the irrational part of the
    # ratio of the moduli of two cylinders which always appear on the 12-gon
    # TODO: clean up this computation; check to make sure naming conventions are followed
    print("computing equations arising from rational moduli")

    # wi_scaled are the projection of 
    w2_scaled = (dist_along_transversal(make_60_deg_sym_gon().vertices[2])-\
        dist_along_transversal(make_60_deg_sym_gon().vertices[1]))
    w1_scaled = (dist_along_transversal(make_60_deg_sym_gon().vertices[4]) -\
        dist_along_transversal(make_60_deg_sym_gon().vertices[3]))
    w_comp = w2_scaled/w1_scaled

    
    p = make_60_deg_sym_gon().vertices
    m = (p[3].y - p[10].y)/(p[3].x - p[10].x)
    parallel2 = eqn_for_line_point_slope(p[2], m)
    side = eqn_for_line_2pts(p[11], p[0])
    pt2 = intersection(*parallel2, *side)
    parallel1 = eqn_for_line_point_slope(p[1], m)
    pt1 = intersection(*parallel1, *side)

    h2 = (p[2].x - pt2.x) + (p[1].x - pt1.x)
    h1 = (make_60_deg_sym_gon().vertices[4].x - make_60_deg_sym_gon().vertices[9].x)
    h_comp = h1/h2

    irr_mod1 = (w_comp*h_comp).irrational(D=Integer(3)).numerator()
    equations_to_zero.append(irr_mod1)

    print(equations_to_zero[:-1])

    # print("equations to zero:", equations_to_zero)
    # compute groebner basis of all the generated equations
    R = QQ['a1, b1, c1, d1']; (a1, b1, c1, d1,) = R._first_ngens(4)
    I = R.ideal(equations_to_zero)
    gb = I.groebner_basis()

    print("computing groebner basis generated by the expressions derived")
    print("from the 60 degree symmetric 12-gon:")
    return gb

# ------------ output ------------
print(compute_60_deg_gb())
