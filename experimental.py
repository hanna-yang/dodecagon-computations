from sage.all import *
from j_invariant_computations import *
from symbolic_wrappers import *
from dodecagon_maker import *
from misc import *

"""
Let the vertices, in clockwise order of the dodecagon, starting from
(1, 0) be v0, v1, v2, ... v11
"""

def compute_60_deg_gb_exp():
    """
    prints out the groebner basis generated by the following expressions
    (set equal to zero)
    - the projection of the j-invariant, Jvv, along the directions of
    vectors connecting:
        -
    - the irrational component of the numerator of
    -
    one can verify that the only solutions are
    b1=c1=0
    and
    a1=0, b1=1/2, c1=1/2, d1=0
    either by hand, or asking sage to solve the series of equations which are printed.
    """
    equations_to_zero = []
    p = make_60_deg_sym_gon()

    # compute the equations corresponding to zero-ing of j-invariant
    exp_assumption = []
    for i in range(2,4):
        exp_assumption += expressions_to_zero(i, polygon=p)[:2]
    nums = [e.numerator()(D=Integer(3)) for e in exp_assumption if e is not None]
    equations_to_zero += nums

    print("finished computing jvv")

    # compute the equations corresponding the zero-ing of 
    irrational_iet = ((dist_along_transversal(p.vertices[3]) - dist_along_transversal(p.vertices[2]))/(dist_along_transversal(p.vertices[1]) - dist_along_transversal(p.vertices[0]))).irrational(D=3).numerator() 
    equations_to_zero.append(irrational_iet)

    # compute the equations corresponding the zero-ing of 
    irrational_moduli = ((dist_along_transversal(p.vertices[4]) - dist_along_transversal(p.vertices[3]))/(dist_along_transversal(p.vertices[11]) - dist_along_transversal(p.vertices[0]))).irrational(D=3).numerator() 
    equations_to_zero.append(irrational_moduli)

    print("finished computing irrational constraints")

    exp, sym = compute_all_jxy(p) 

    print("computing eqn for jxy")
    for i in range(2):
        equations_to_zero.append((sym[i][0].numerator()(3)*sym[i][1].denominator()(3) - sym[i][1].numerator()(3)*sym[i][0].denominator()(3)))

    print("finished computing jxy")

    # print("equations to zero:", equations_to_zero)
    # compute groebner basis of all the generated equations
    R = QQ['a1, b1, c1, d1']; (a1, b1, c1, d1,) = R._first_ngens(4)
    I = R.ideal(equations_to_zero)
    gb = I.groebner_basis()

    print("computing groebner basis generated by the expressions derived")
    print("from the 60 degree symmetric 12-gon:")
    return gb

# ------------ output ------------
print("computing the grobner basis for jxy in cylinder directions as well")
print(compute_60_deg_gb_exp())
print("one can verify that the equations which above have only")
print("b1=c1=0 and a1=0, b1=1/2, c1=1/2, d1=0 as solutions")
